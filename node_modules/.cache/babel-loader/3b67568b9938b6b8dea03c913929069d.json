{"ast":null,"code":"import axios from 'axios';\nimport { tokensSelector, refreshTokenRequest, logout } from '../store/auth';\nimport { openNotification } from '../store/notifications';\nconst baseURL = 'http://localhost:3000/api/';\nconst instance = axios.create({\n  baseURL\n});\nconst waitQueue = [];\nlet isRefreshDispatched = false;\n\nconst request = ({\n  url,\n  method,\n  data,\n  headers = {},\n  isRefresh,\n  isWithoutToken,\n  getState = () => ({}),\n  dispatch = () => {}\n}) => new Promise((resolve, reject) => {\n  const _tokensSelector = tokensSelector(getState()),\n        accessToken = _tokensSelector.accessToken,\n        accessTokenExpiredAt = _tokensSelector.accessTokenExpiredAt,\n        refreshTokenExpiredAt = _tokensSelector.refreshTokenExpiredAt; // request handler\n\n\n  const requestFunc = ({\n    url,\n    method,\n    headers,\n    data,\n    resolve,\n    reject\n  }) => {\n    if (!isWithoutToken) {\n      const _tokensSelector2 = tokensSelector(getState()),\n            accessToken = _tokensSelector2.accessToken,\n            refreshToken = _tokensSelector2.refreshToken;\n\n      headers['Authorization'] = isRefresh ? refreshToken : accessToken;\n    }\n\n    return instance({\n      url,\n      method,\n      headers,\n      data\n    }).then(response => {\n      resolve(response.data);\n    }).catch(error => {\n      if (error.response) {\n        const status = error.response.status || 404;\n        const errorResponse = error.response.data;\n        console.group('Error from: ' + url);\n        console.info('Status: ' + status);\n        console.dir(errorResponse);\n        console.groupEnd();\n\n        switch (status) {\n          case 401:\n          case 403:\n            dispatch(logout());\n            return reject(errorResponse);\n\n          case 500:\n          case 502:\n          case 503:\n            dispatch(openNotification({\n              variant: 'error',\n              text: \"\".concat(status, \"!\\nSomething is wrong))\")\n            }));\n            return reject({\n              detail: 'Unknown error'\n            });\n\n          default:\n            return reject(errorResponse);\n        }\n      } else {\n        dispatch(openNotification({\n          variant: 'error',\n          text: \"Error!!\\n\".concat(error.message)\n        }));\n        return reject(error.message);\n      }\n    });\n  };\n\n  const isTokenExpired = accessTokenExpiredAt <= Date.now();\n  const isRefreshExpired = refreshTokenExpiredAt <= Date.now(); // If should refresh token\n\n  if (accessToken && isTokenExpired && !isRefreshExpired && !isWithoutToken) {\n    // push original request to waiting stack\n    !isRefresh && waitQueue.push({\n      url,\n      method,\n      data,\n      headers,\n      isRefresh,\n      resolve,\n      reject\n    }); // dispatch refresh token (first-time only!)\n\n    if (!isRefresh && !isRefreshDispatched) {\n      isRefreshDispatched = true;\n      dispatch(refreshTokenRequest()).then(() => {\n        isRefreshDispatched = false; // and after refresh - execute requests from waiting stack\n\n        waitQueue.forEach(config => requestFunc(config));\n      }).catch(() => {\n        // by default in error - logout user\n        dispatch(logout()); // eslint-disable-next-line\n\n        reject({\n          detail: 'Refresh token error'\n        });\n      });\n    } else if (isRefresh) {\n      // if has been called refresh method\n      requestFunc({\n        url,\n        method,\n        data,\n        headers,\n        resolve,\n        reject\n      });\n    }\n  } else if (isRefreshExpired && !isWithoutToken) {\n    // if refresh is expired - just logout\n    dispatch(logout()); // eslint-disable-next-line\n\n    reject({\n      detail: 'Refresh token is expired'\n    });\n  } else {\n    // by default\n    requestFunc({\n      url,\n      method,\n      data,\n      headers,\n      resolve,\n      reject\n    });\n  }\n});\n\nexport default request;","map":{"version":3,"sources":["/Users/tweecezor/Desktop/nodeJS/src/helpers/request.js"],"names":["axios","tokensSelector","refreshTokenRequest","logout","openNotification","baseURL","instance","create","waitQueue","isRefreshDispatched","request","url","method","data","headers","isRefresh","isWithoutToken","getState","dispatch","Promise","resolve","reject","accessToken","accessTokenExpiredAt","refreshTokenExpiredAt","requestFunc","refreshToken","then","response","catch","error","status","errorResponse","console","group","info","dir","groupEnd","variant","text","detail","message","isTokenExpired","Date","now","isRefreshExpired","push","forEach","config"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,cAAT,EAAyBC,mBAAzB,EAA8CC,MAA9C,QAA4D,eAA5D;AACA,SAASC,gBAAT,QAAiC,wBAAjC;AACA,MAAMC,OAAO,GAAG,4BAAhB;AACA,MAAMC,QAAQ,GAAGN,KAAK,CAACO,MAAN,CAAa;AAAEF,EAAAA;AAAF,CAAb,CAAjB;AAEA,MAAMG,SAAS,GAAG,EAAlB;AACA,IAAIC,mBAAmB,GAAG,KAA1B;;AAEA,MAAMC,OAAO,GAAG,CAAC;AACfC,EAAAA,GADe;AAEfC,EAAAA,MAFe;AAGfC,EAAAA,IAHe;AAIfC,EAAAA,OAAO,GAAG,EAJK;AAKfC,EAAAA,SALe;AAMfC,EAAAA,cANe;AAOfC,EAAAA,QAAQ,GAAG,OAAO,EAAP,CAPI;AAQfC,EAAAA,QAAQ,GAAG,MAAM,CAAE;AARJ,CAAD,KAUd,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAAA,0BAM3BpB,cAAc,CAACgB,QAAQ,EAAT,CANa;AAAA,QAG7BK,WAH6B,mBAG7BA,WAH6B;AAAA,QAI7BC,oBAJ6B,mBAI7BA,oBAJ6B;AAAA,QAK7BC,qBAL6B,mBAK7BA,qBAL6B,EAQ/B;;;AACA,QAAMC,WAAW,GAAG,CAAC;AAAEd,IAAAA,GAAF;AAAOC,IAAAA,MAAP;AAAeE,IAAAA,OAAf;AAAwBD,IAAAA,IAAxB;AAA8BO,IAAAA,OAA9B;AAAuCC,IAAAA;AAAvC,GAAD,KAAqD;AACvE,QAAI,CAACL,cAAL,EAAqB;AAAA,+BAIff,cAAc,CAACgB,QAAQ,EAAT,CAJC;AAAA,YAEjBK,WAFiB,oBAEjBA,WAFiB;AAAA,YAGjBI,YAHiB,oBAGjBA,YAHiB;;AAKlBZ,MAAAA,OAAO,CAAC,eAAD,CAAP,GAA2BC,SAAS,GAAGW,YAAH,GAAkBJ,WAAvD;AACD;;AAED,WAAOhB,QAAQ,CAAC;AAAEK,MAAAA,GAAF;AAAOC,MAAAA,MAAP;AAAeE,MAAAA,OAAf;AAAwBD,MAAAA;AAAxB,KAAD,CAAR,CACJc,IADI,CACCC,QAAQ,IAAI;AAChBR,MAAAA,OAAO,CAACQ,QAAQ,CAACf,IAAV,CAAP;AACD,KAHI,EAIJgB,KAJI,CAIEC,KAAK,IAAI;AACd,UAAIA,KAAK,CAACF,QAAV,EAAoB;AAClB,cAAMG,MAAM,GAAGD,KAAK,CAACF,QAAN,CAAeG,MAAf,IAAyB,GAAxC;AACA,cAAMC,aAAa,GAAGF,KAAK,CAACF,QAAN,CAAef,IAArC;AACAoB,QAAAA,OAAO,CAACC,KAAR,CAAc,iBAAiBvB,GAA/B;AACAsB,QAAAA,OAAO,CAACE,IAAR,CAAa,aAAaJ,MAA1B;AACAE,QAAAA,OAAO,CAACG,GAAR,CAAYJ,aAAZ;AACAC,QAAAA,OAAO,CAACI,QAAR;;AAEA,gBAAQN,MAAR;AACE,eAAK,GAAL;AACA,eAAK,GAAL;AACEb,YAAAA,QAAQ,CAACf,MAAM,EAAP,CAAR;AACA,mBAAOkB,MAAM,CAACW,aAAD,CAAb;;AACF,eAAK,GAAL;AACA,eAAK,GAAL;AACA,eAAK,GAAL;AACEd,YAAAA,QAAQ,CACNd,gBAAgB,CAAC;AACfkC,cAAAA,OAAO,EAAE,OADM;AAEfC,cAAAA,IAAI,YAAKR,MAAL;AAFW,aAAD,CADV,CAAR;AAMA,mBAAOV,MAAM,CAAC;AAAEmB,cAAAA,MAAM,EAAE;AAAV,aAAD,CAAb;;AACF;AACE,mBAAOnB,MAAM,CAACW,aAAD,CAAb;AAhBJ;AAkBD,OA1BD,MA0BO;AACLd,QAAAA,QAAQ,CACNd,gBAAgB,CAAC;AACfkC,UAAAA,OAAO,EAAE,OADM;AAEfC,UAAAA,IAAI,qBAAcT,KAAK,CAACW,OAApB;AAFW,SAAD,CADV,CAAR;AAMA,eAAOpB,MAAM,CAACS,KAAK,CAACW,OAAP,CAAb;AACD;AACF,KAxCI,CAAP;AAyCD,GAlDD;;AAoDA,QAAMC,cAAc,GAAGnB,oBAAoB,IAAIoB,IAAI,CAACC,GAAL,EAA/C;AACA,QAAMC,gBAAgB,GAAGrB,qBAAqB,IAAImB,IAAI,CAACC,GAAL,EAAlD,CA9D+B,CAgE/B;;AACA,MAAItB,WAAW,IAAIoB,cAAf,IAAiC,CAACG,gBAAlC,IAAsD,CAAC7B,cAA3D,EAA2E;AACzE;AACA,KAACD,SAAD,IACEP,SAAS,CAACsC,IAAV,CAAe;AACbnC,MAAAA,GADa;AAEbC,MAAAA,MAFa;AAGbC,MAAAA,IAHa;AAIbC,MAAAA,OAJa;AAKbC,MAAAA,SALa;AAMbK,MAAAA,OANa;AAObC,MAAAA;AAPa,KAAf,CADF,CAFyE,CAazE;;AACA,QAAI,CAACN,SAAD,IAAc,CAACN,mBAAnB,EAAwC;AACtCA,MAAAA,mBAAmB,GAAG,IAAtB;AACAS,MAAAA,QAAQ,CAAChB,mBAAmB,EAApB,CAAR,CACGyB,IADH,CACQ,MAAM;AACVlB,QAAAA,mBAAmB,GAAG,KAAtB,CADU,CAEV;;AACAD,QAAAA,SAAS,CAACuC,OAAV,CAAkBC,MAAM,IAAIvB,WAAW,CAACuB,MAAD,CAAvC;AACD,OALH,EAMGnB,KANH,CAMS,MAAM;AACX;AACAX,QAAAA,QAAQ,CAACf,MAAM,EAAP,CAAR,CAFW,CAGX;;AACAkB,QAAAA,MAAM,CAAC;AAAEmB,UAAAA,MAAM,EAAE;AAAV,SAAD,CAAN;AACD,OAXH;AAYD,KAdD,MAcO,IAAIzB,SAAJ,EAAe;AACpB;AACAU,MAAAA,WAAW,CAAC;AAAEd,QAAAA,GAAF;AAAOC,QAAAA,MAAP;AAAeC,QAAAA,IAAf;AAAqBC,QAAAA,OAArB;AAA8BM,QAAAA,OAA9B;AAAuCC,QAAAA;AAAvC,OAAD,CAAX;AACD;AACF,GAhCD,MAgCO,IAAIwB,gBAAgB,IAAI,CAAC7B,cAAzB,EAAyC;AAC9C;AACAE,IAAAA,QAAQ,CAACf,MAAM,EAAP,CAAR,CAF8C,CAG9C;;AACAkB,IAAAA,MAAM,CAAC;AAAEmB,MAAAA,MAAM,EAAE;AAAV,KAAD,CAAN;AACD,GALM,MAKA;AACL;AACAf,IAAAA,WAAW,CAAC;AAAEd,MAAAA,GAAF;AAAOC,MAAAA,MAAP;AAAeC,MAAAA,IAAf;AAAqBC,MAAAA,OAArB;AAA8BM,MAAAA,OAA9B;AAAuCC,MAAAA;AAAvC,KAAD,CAAX;AACD;AACF,CA1GD,CAVF;;AAsHA,eAAeX,OAAf","sourcesContent":["import axios from 'axios';\nimport { tokensSelector, refreshTokenRequest, logout } from '../store/auth';\nimport { openNotification } from '../store/notifications';\nconst baseURL = 'http://localhost:3000/api/';\nconst instance = axios.create({ baseURL });\n\nconst waitQueue = [];\nlet isRefreshDispatched = false;\n\nconst request = ({\n  url,\n  method,\n  data,\n  headers = {},\n  isRefresh,\n  isWithoutToken,\n  getState = () => ({}),\n  dispatch = () => {}\n}) =>\n  new Promise((resolve, reject) => {\n    \n    const {\n      accessToken,\n      accessTokenExpiredAt,\n      refreshTokenExpiredAt\n    } = tokensSelector(getState());\n\n    // request handler\n    const requestFunc = ({ url, method, headers, data, resolve, reject }) => {\n      if (!isWithoutToken) {\n        const {\n          accessToken,\n          refreshToken,\n        } = tokensSelector(getState());\n        (headers['Authorization'] = isRefresh ? refreshToken : accessToken);\n      }\n\n      return instance({ url, method, headers, data })\n        .then(response => {\n          resolve(response.data);\n        })\n        .catch(error => {\n          if (error.response) {\n            const status = error.response.status || 404;\n            const errorResponse = error.response.data;\n            console.group('Error from: ' + url);\n            console.info('Status: ' + status);\n            console.dir(errorResponse);\n            console.groupEnd();\n\n            switch (status) {\n              case 401:\n              case 403:\n                dispatch(logout())\n                return reject(errorResponse);\n              case 500:\n              case 502:\n              case 503:\n                dispatch(\n                  openNotification({\n                    variant: 'error',\n                    text: `${status}!\\nSomething is wrong))`\n                  })\n                );\n                return reject({ detail: 'Unknown error' });\n              default:\n                return reject(errorResponse);\n            }\n          } else {\n            dispatch(\n              openNotification({\n                variant: 'error',\n                text: `Error!!\\n${error.message}`\n              })\n            );\n            return reject(error.message);\n          }\n        });\n    };\n\n    const isTokenExpired = accessTokenExpiredAt <= Date.now();\n    const isRefreshExpired = refreshTokenExpiredAt <= Date.now();\n\n    // If should refresh token\n    if (accessToken && isTokenExpired && !isRefreshExpired && !isWithoutToken) {\n      // push original request to waiting stack\n      !isRefresh &&\n        waitQueue.push({\n          url,\n          method,\n          data,\n          headers,\n          isRefresh,\n          resolve,\n          reject\n        });\n\n      // dispatch refresh token (first-time only!)\n      if (!isRefresh && !isRefreshDispatched) {\n        isRefreshDispatched = true;\n        dispatch(refreshTokenRequest())\n          .then(() => {\n            isRefreshDispatched = false;\n            // and after refresh - execute requests from waiting stack\n            waitQueue.forEach(config => requestFunc(config));\n          })\n          .catch(() => {\n            // by default in error - logout user\n            dispatch(logout())\n            // eslint-disable-next-line\n            reject({ detail: 'Refresh token error' });\n          });\n      } else if (isRefresh) {\n        // if has been called refresh method\n        requestFunc({ url, method, data, headers, resolve, reject });\n      }\n    } else if (isRefreshExpired && !isWithoutToken) {\n      // if refresh is expired - just logout\n      dispatch(logout())\n      // eslint-disable-next-line\n      reject({ detail: 'Refresh token is expired' });\n    } else {\n      // by default\n      requestFunc({ url, method, data, headers, resolve, reject });\n    }\n  });\n\nexport default request;\n"]},"metadata":{},"sourceType":"module"}